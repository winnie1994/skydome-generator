<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Skydome Generator</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
      background-color: black;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      outline: none; /* Remove default focus outline */
      touch-action: none;
    }
  </style>

</head>
<body>
  <canvas id="canvas" tabindex="0"></canvas>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter.js";
    import { GUI } from "lil-gui";

    const PARAMETERS = {
      ground_plane_height: -0.5,
      boundary_rounding: -0.5,
      ground_plane_stretching: 0.5,
      rotation: true,
      uploadTexture: function() {
        // This will be overridden by the file input
      },
      exportGLB: function() {
        // This will be overridden by the export function
      }
    };
    const PANO_URL = "https://storage.googleapis.com/forge-dev-public/redwoods_pano.png"
    
    const canvas = document.getElementById("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setClearColor(new THREE.Color(0x000000), 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.01,
      1000,
    );
    camera.position.set(0, 1, 4);
    camera.lookAt(0, 0, 0);
    scene.add(camera);

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.target.set(0, 0, 0);
    function handleResize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    handleResize();
    window.addEventListener("resize", handleResize);
    
    // Function to update the sky texture
    function updateSkyTexture(skyMesh, textureUrl) {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(textureUrl, (texture) => {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        skyMesh.material.map = texture;
        skyMesh.material.needsUpdate = true;
      });
    }
    
    // Function to handle file upload
    function handleFileUpload(file, skyMesh) {
      if (file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(e) {
          updateSkyTexture(skyMesh, e.target.result);
        };
        reader.readAsDataURL(file);
      }
    }
    
    // Function to export hemisphere as GLB
    function exportHemisphereAsGLB(skyMesh) {
      const exporter = new GLTFExporter();
      
      // Clone the mesh to avoid modifying the original
      const exportMesh = skyMesh.clone();
      
      // Export options
      const options = {
        binary: true, // Export as GLB (binary format)
        embedImages: true, // Include textures in the GLB file
        animations: [],
        onlyVisible: true
      };
      
      exporter.parse(
        exportMesh,
        function(result) {
          // Create download link
          const blob = new Blob([result], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'hemisphere.glb';
          link.click();
          URL.revokeObjectURL(url);
        },
        function(error) {
          console.error('Error exporting GLB:', error);
        },
        options
      );
    }
    
    async function buildSkyHemisphere(pano_image_url) {
      // Create sky hemisphere with a ground plane
      const textureLoader = new THREE.TextureLoader();
      const skyTexture = await new Promise((resolve, reject) => {
        textureLoader.load(pano_image_url, resolve, undefined, reject);
      });
      skyTexture.mapping = THREE.EquirectangularReflectionMapping;
      
      const skyGeometry = new THREE.SphereGeometry(1.0, 32, 128);
      const skyMaterial = new THREE.MeshBasicMaterial({
        map: skyTexture,
        side: THREE.BackSide
      });
      const skySphere = new THREE.Mesh(skyGeometry, skyMaterial);
      
      // Store original positions for resetting
      const originalPositions = skyGeometry.attributes.position.array.slice();
      skySphere.userData.originalPositions = originalPositions;
      
      return skySphere;
    }

    function updateHemisphere(skyMesh) {
      const ground_plane_height = PARAMETERS.ground_plane_height;
      const boundary_rounding = PARAMETERS.boundary_rounding;
      const ground_plane_stretching = PARAMETERS.ground_plane_stretching;
      
      // Reset to original positions before applying transformation
      const positions = skyMesh.geometry.attributes.position.array;
      const originalPositions = skyMesh.userData.originalPositions;
      for (let i = 0; i < positions.length; i++) {
        positions[i] = originalPositions[i];
      }
      
      // Project lower half vertices to ground plane
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];
        
        if (y < 0) {
          if (y < boundary_rounding) {
            const falloff_xz = ((boundary_rounding - y) / (1.0 + boundary_rounding)) ** 1.5;
            const scale_xz = falloff_xz * ground_plane_stretching + (1.0 - falloff_xz);
            positions[i] *= scale_xz;
            positions[i + 2] *= scale_xz;
          }
          if (y > ground_plane_height) {
            const falloff_y = (y / ground_plane_height) ** 1.5;
            positions[i + 1] = falloff_y * ground_plane_height + (1.0 - falloff_y) * positions[i + 1];
          } else { // clamp to ground plane
            positions[i + 1] = ground_plane_height;
          }
        }
      }
      skyMesh.geometry.attributes.position.needsUpdate = true;
      skyMesh.needsUpdate = true;
    }
    const skyMesh = await buildSkyHemisphere(PANO_URL);
    scene.add(skyMesh);
    updateHemisphere(skyMesh);
    
    const gui = new GUI();
    
    
    // Add file upload button
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        handleFileUpload(file, skyMesh);
      }
    });
    document.body.appendChild(fileInput);
    
    // Override the uploadTexture function to trigger file input
    PARAMETERS.uploadTexture = function() {
      fileInput.click();
    };
    
    gui.add(PARAMETERS, "uploadTexture").name("Upload Panorama");
    
    // Override the exportGLB function to trigger export
    PARAMETERS.exportGLB = function() {
      exportHemisphereAsGLB(skyMesh);
    };
    gui.add(PARAMETERS, "ground_plane_height").min(-1.0).max(0.0).step(0.01).onChange((value) => {
      updateHemisphere(skyMesh);
    });
    gui.add(PARAMETERS, "boundary_rounding").min(-1.0).max(0.0).step(0.01).onChange((value) => {
      updateHemisphere(skyMesh);
    });
    gui.add(PARAMETERS, "ground_plane_stretching").min(0.01).max(1.0).step(0.01).onChange((value) => {
      updateHemisphere(skyMesh);
    });
    gui.add(PARAMETERS, "rotation");
    
    gui.add(PARAMETERS, "exportGLB").name("Export as GLB");
    
    console.log("Starting render loop");

    // Animation loop
    let lastTime = 0;
    renderer.setAnimationLoop((raw_time) => {
      raw_time *= 0.0001;
      const deltaTime = raw_time - (lastTime ?? raw_time);
      lastTime = raw_time;
      orbitControls.update();
      renderer.render(scene, camera);

      if (PARAMETERS.rotation) {
        skyMesh.rotation.y += deltaTime;
      }
    });
</script>
</body>
</html>
